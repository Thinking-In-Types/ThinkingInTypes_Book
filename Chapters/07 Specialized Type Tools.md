# Specialized Type Tools

> This placeholder text was generated by ChatGPT 4.5.
> It will be significantly rewritten as the book is developed.
> In the meantime you can add comments to either <https://bsky.app/bruceeckel> or [Github Issues](https://github.com/Thinking-In-Types/ThinkingInTypes_Book/issues).

## Misunderstanding Class Variables

Class annotations provide explicit type definitions for attributes and methods, increasing clarity and ensuring type consistency:

```python
# example_1.py
class User:
    # Misunderstanding of class variables; add blog post here
    # username: str
    # age: int

    def __init__(self, username: str, age: int):
        self.username = username
        self.age = age

    def greet(self) -> str:
        return f"Hello, {self.username}!"
```

Annotations help document the intended use of class members and improve maintainability.

## Typed NamedTuples: Definition and Use

Typed `NamedTuple` combines tuple immutability with type annotations and named fields:

```python
# example_2.py
from typing import NamedTuple

class Coordinates(NamedTuple):
    latitude: float
    longitude: float

coords = Coordinates(51.5074, -0.1278)
print(coords.latitude)  # 51.5074
```

`NamedTuple` provides clarity, immutability, and easy unpacking, ideal for simple structured data.

## Leveraging TypedDicts for Structured Data

`TypedDict` is useful when defining dictionary structures with known keys and typed values:

```python
# example_3.py
from typing import TypedDict

class UserProfile(TypedDict):
    username: str
    email: str
    age: int

user: UserProfile = {"username": "alice", "email": "alice@example.com", "age": 30}
```

`TypedDict` clarifies expected keys and types, providing type safety for dictionary data.

### Optional Fields in TypedDict

You can specify optional fields using `NotRequired` (Python 3.11+) or `total=False`:

```python
# example_4.py
from typing import TypedDict, NotRequired

class UserSettings(TypedDict):
    theme: str
    notifications_enabled: NotRequired[bool]

settings: UserSettings = {"theme": "dark"}
```

This flexibility allows clear definitions for complex, partially-optional data structures.

## Patterns for Strongly-Typed Domain Models

Strongly-typed domain models help clearly represent domain logic, improving robustness and maintainability:

### Using Dataclasses and Enums

```python
# example_5.py
from dataclasses import dataclass
from enum import Enum

class Status(Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"

@dataclass
class User:
    id: int
    name: str
    status: Status

user = User(id=1, name="Alice", status=Status.ACTIVE)
```

### Combining Dataclasses with Protocols

```python
# example_6.py
from typing import Protocol

class Identifiable(Protocol):
    id: int

@dataclass
class User:
    id: int
    name: str

@dataclass
class Product:
    id: int
    price: float

def print_id(entity: Identifiable) -> None:
    print(f"ID: {entity.id}")

print_id(User(1, "Alice"))
print_id(Product(101, 19.99))
```

### Domain-driven Design Example

Define domain entities explicitly to enhance domain logic expressiveness:

```python
# example_7.py
@dataclass
class Order:
    order_id: int
    products: List[Product]

    def total_price(self) -> float:
        return sum(product.price for product in self.products)
```

Strongly-typed domain models help catch issues early, facilitating clearer, safer, and more maintainable codebases.
